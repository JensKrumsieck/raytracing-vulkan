#version 450
#extension GL_GOOGLE_include_directive : require

#include "./include/random.glsl"
#include "./include/constants.glsl"

layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;
layout(binding = 0, rgba8) uniform writeonly image2D resultImage;
layout(binding = 1, std140) uniform SceneData{
    mat4 camProj;
    mat4 invCamProj;
    mat4 camView;
    mat4 invCamView;
    uint frameIndex;
} sceneData;

struct ray {
    vec3 origin;
    vec3 direction;
};

struct sphere {
    vec3 center;
    float radius;
};

struct payload {
    vec3 hitPoint;
    vec3 normal;
    float hitDistance;
};

bool hitSphere(sphere sphere, ray ray, inout payload payload)
{
    //solve sphere equation
    vec3 origin = ray.origin - sphere.center;
    
    float a = dot(ray.direction, ray.direction);
    float b = 2 * dot(origin, ray.direction);
    float c = dot(origin, origin) - sphere.radius * sphere.radius;

    float discriminant = b * b - 4 * a * c;
    if (discriminant < 0) return false;
    
    //calculate hitpoint and normal
    float t = (-b - sqrt(discriminant)) / (2.0 * a);
    
    if (t <= 0.001) return false;
    
    payload.hitDistance = t;
    
    vec3 hitPoint = ray.origin + t * ray.direction;
    payload.hitPoint = hitPoint;
    
    vec3 normal = normalize(hitPoint - sphere.center);
    if(dot(normal, ray.direction) >= 0) normal = -1 * normal;
    payload.normal = normal;
    
    return true;
}

vec3 GetRayDirection(vec2 coord)
{
    vec4 target = sceneData.invCamProj * vec4(coord.xy, 1, 1);
    vec3 dir = vec3(sceneData.invCamView * vec4(normalize(vec3(target.xyz / target.w)), 0));
    return normalize(dir);
}

vec3 PerPixel(ray ray)
{    
    sphere spheres[2];
    spheres[0] = sphere(vec3(0,0, -1), -0.5);
    spheres[1] = sphere(vec3(0,-100.5, -1), 100);
    
    uint maxBounces = 10;
    vec3 finalColor = vec3(0);
    vec3 color = vec3(1);
        
    for(int d = 0; d < maxBounces; d++) {
        payload localPayload;
        payload payload;
        bool hit = false;
        float closestT = infinity;
        for(int i = 0; i < spheres.length(); i++)
        {
            if (hitSphere(spheres[i], ray, localPayload))
            {
                hit = true;
                if (localPayload.hitDistance < closestT)
                {
                    closestT = localPayload.hitDistance;
                    payload = localPayload;
                }
            }
        }

        if (hit) {
            color *= 0.5;
            ray.origin = payload.hitPoint + payload.normal * 0.001;
            ray.direction = payload.normal + randomUnitVector();
        }
        else {
            vec3 unitDir = normalize(ray.direction);
            float a = 0.5 * (unitDir.y + 1.0);
            vec3 skyColor =  (1.0 - a * vec3(1) + a * vec3(0.5, 0.7, 1.0));
            finalColor = color * skyColor;
            break;
        }        
    }
    return finalColor;
}

void main() 
{ 
    vec2 imageSize = vec2(imageSize(resultImage));
    
    //calculate uv coords
    vec2 uv = (gl_GlobalInvocationID.xy + 0.5) / imageSize.xy; //ndc space
    uv.x = uv.x * 2 - 1; //screen space x
    uv.y = 1 - uv.y * 2; //screen space y

    //modify random seed
    gState *= floatBitsToUint(uv.y * uv.x / 1000) * gl_GlobalInvocationID.x * sceneData.frameIndex;
    
    vec3 origin = sceneData.invCamView[3].xyz;

    //anti aliasing
    uint samplesPerPixel = 10;
    float influence = 0.005;
    vec3 color = vec3(0);    
    for(int i = 0; i < samplesPerPixel; i++) {
        vec3 dir = GetRayDirection(uv) + influence * hash3();
        ray ray = ray(origin, dir);
        color += PerPixel(ray);
    }
    color /= samplesPerPixel;
    color = clamp(color, 0, 1);
    
    imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(color, 1));
}